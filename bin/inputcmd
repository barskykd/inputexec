#!/usr/bin/env python

import ConfigParser
import Queue
import signal
import shlex
import subprocess
import sys
import threading
import time

ACTIONS_SECTION = 'actions'


class Task(object):
    def __init__(self, line, command):
        self.line = line
        self.command = command

    def __repr__(self):
        return 'Task(%r, %r)' % (self.line, self.command)


class ActionThread(threading.Thread):
    def __init__(self, queue, stopped, *args, **kwargs):
        self.queue = queue
        self.stopped = stopped
        super(ActionThread, self).__init__(*args, **kwargs)

    def run(self):
        while True:
            if self.stopped.is_set():
                break
            task = self.queue.get()

            try:
                print "%s => `%s`" % (task.line, task.command)
                args = shlex.split(task.command)
                p = subprocess.Popen(args, stdout=subprocess.PIPE)
                p.communicate()
                if p.returncode != 0:
                    print "Child %d terminated with %d" % (p.pid, p.returncode)
            finally:
                self.queue.task_done()


class SignalSetter(object):
    def __init__(self, target_signal, handler):
        self.target_signal = target_signal
        self.handler = handler
        self.old_handler = lambda signum, frame: None

    def __enter__(self):
        self.old_handler = signal.signal(self.target_signal, self.handler)

    def __exit__(self, *args, **kwargs):
        signal.signal(self.target_signal, self.old_handler)


class Runner(object):
    def __init__(self, config):
        self.config = config
        self.action_queue = Queue.Queue()
        self.stopped = threading.Event()

    def install_signal_handler(self):
        def _handler(_signum, _frame):
            #print "Stopping."
            self.stopped.set()

        return SignalSetter(signal.SIGTERM, _handler)

    def handle(self, line):
        #print "Handling action %s" % line
        try:
            action = self.config.get(ACTIONS_SECTION, line)
        except (ConfigParser.NoSectionError, ConfigParser.NoOptionError):
            return

        self.action_queue.put(Task(line, action))

    def start_action_thread(self):
        thread = ActionThread(self.action_queue, self.stopped)
        thread.daemon = True
        thread.start()

    def run(self, source):
        with self.install_signal_handler():
            self.start_action_thread()
            while True:
                line = source.readline()
                if line == '':
                    break
                #print "Read line %r" % line
                self.handle(line[:-1])

            #print "No more lines."

            self.action_queue.join()
        #while True:
        #    if self.stopped.set() or self.action_queue.empty():
        #        break
        #    print "Neither stopped nor empty, sleeping."
        #    time.sleep(1)
        #print "Finished."


class Setup(object):
    def read_config(self, filename):
        parser = ConfigParser.SafeConfigParser()
        parser.read(filename)
        return parser

    def run(self, argv):
        config = self.read_config(argv[1])
        runner = Runner(config)
        try:
            runner.run(sys.stdin)
        except KeyboardInterrupt:
            pass


def main(argv):
    setup = Setup()
    setup.run(argv)

if __name__ == '__main__':
    main(sys.argv)
